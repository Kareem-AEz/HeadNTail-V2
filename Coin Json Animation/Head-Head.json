{"v":"5.12.1","fr":24,"ip":0,"op":71,"w":302,"h":304,"nm":"z Main","ddd":0,"assets":[{"id":"image_0","w":448,"h":448,"u":"","p":"data:image/png;base64,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","e":1},{"id":"image_1","w":1,"h":1,"u":"","p":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAEAQMAAACTPww9AAAAJHpUWHRDcmVhdG9yAAAImXNMyU9KVXBMK0ktUnBNS0tNLikGAEF6Bs5qehXFAAAACXBIWXMAAAABAAAAAQBPJcTWAAAAA1BMVEVHcEyC+tLSAAAAAXRSTlMAQObYZgAAAAtJREFUCNdjYIAAAAAIAAEvIN0xAAAAAElFTkSuQmCC","e":1},{"id":"image_2","w":448,"h":448,"u":"","p":"data:image/png;base64,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","e":1},{"id":"image_3","w":450,"h":450,"u":"","p":"data:image/png;base64,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","e":1},{"id":"comp_0","nm":"Head Tail","fr":24,"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"MAP || Comp 1 || circle_1 || BACK","refId":"comp_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('circle_1').effect('Extrudalizer')('Back opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[150,150,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('circle_1');\nconst is_front = false;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,167.4],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = $bm_neg(thisLayer.width);\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'back';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 17;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'Back';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositions Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":72,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":0,"nm":"MAP || Comp 1 || circle_1 || FRONT","refId":"comp_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11,"x":"var $bm_rt;\n$bm_rt = thisComp.layer('circle_1').effect('Extrudalizer')('Front opacity readout');"},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[150,150,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":35,"nm":"Transform","np":14,"mn":"ADBE Geometry2","ix":1,"en":1,"ef":[{"ty":3,"nm":"Anchor Point","mn":"ADBE Geometry2-0001","ix":1,"v":{"a":0,"k":[150,150],"ix":1,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('circle_1');\nconst is_front = true;\nconst precomp_width = 300;\nlet extr_data_arr = [];\nlet is_facing_us = false;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    $bm_rt = is_facing_us = extr_data_arr[8];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    $bm_rt = is_facing_us = extr_data_arr[8] == 'true';\n}\nfunction logicalXOR(input1, input2) {\n    return input1 && !input2 || !input1 && input2;\n}\nif (logicalXOR(is_front, is_facing_us)) {\n    $bm_rt = value = [\n        precomp_width,\n        0\n    ];\n} else {\n    $bm_rt = value = [\n        0,\n        0\n    ];\n}"}},{"ty":3,"nm":"Position","mn":"ADBE Geometry2-0002","ix":2,"v":{"a":0,"k":[150,150],"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst POS_INDEX_LOTTIE = 0;\nconst POS_INDEX_1 = 0;\nconst POS_INDEX_2 = 1;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let pos = [\n        0,\n        0\n    ];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        $bm_rt = pos = transform_effect_controls[POS_INDEX_LOTTIE];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        $bm_rt = pos = [\n            transform_effect_controls[POS_INDEX_1],\n            transform_effect_controls[POS_INDEX_2]\n        ];\n    }\n}"}},{"ty":7,"nm":"Uniform Scale","mn":"ADBE Geometry2-0011","ix":3,"v":{"a":0,"k":0,"ix":3}},{"ty":0,"nm":"Scale Height","mn":"ADBE Geometry2-0003","ix":4,"v":{"a":0,"k":100,"ix":4,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 3;\nconst control_index_ae = 4;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.height;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Scale Width","mn":"ADBE Geometry2-0004","ix":5,"v":{"a":0,"k":100,"ix":5,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 4;\nconst control_index_ae = 5;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = thisLayer.width;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew","mn":"ADBE Geometry2-0005","ix":6,"v":{"a":0,"k":0,"ix":6,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 2;\nconst control_index_ae = 3;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Skew Axis","mn":"ADBE Geometry2-0006","ix":7,"v":{"a":0,"k":0,"ix":7,"x":"var $bm_rt;\n$bm_rt = $bm_neg(effect('Transform')('ADBE Geometry2-0007'));"}},{"ty":0,"nm":"Rotation","mn":"ADBE Geometry2-0007","ix":8,"v":{"a":0,"k":0,"ix":8,"x":"var $bm_rt;\n'use native operators';\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'front';\nconst use_bb = ex_layer.effect('Extrudalizer')('Compute 3D ' + face + ' bounding box').value;\nconst data_index = 16;\nconst control_index_lt = 1;\nconst control_index_ae = 2;\nif (!use_bb) {\n    $bm_rt = value;\n} else {\n    let extr_data_arr;\n    let transform_effect_controls = [];\n    let control_value;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        transform_effect_controls = extr_data_arr[data_index];\n        control_value = transform_effect_controls[control_index_lt];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        transform_effect_controls = extr_data_arr[data_index].split(',').map(s => parseFloat(s));\n        control_value = parseFloat(transform_effect_controls[control_index_ae]);\n    }\n    const k = 1;\n    control_value = $bm_div(control_value, k);\n    $bm_rt = control_value;\n}"}},{"ty":0,"nm":"Opacity","mn":"ADBE Geometry2-0008","ix":9,"v":{"a":0,"k":100,"ix":9,"x":"var $bm_rt;\nconst ex_layer = thisComp.layer('circle_1');\nconst face = 'Front';\nconst face_opacity = ex_layer.effect('Extrudalizer')(face + ' opacity readout').value;\n$bm_rt = face_opacity;"}},{"ty":7,"nm":"Use Compositions Shutter Angle","mn":"ADBE Geometry2-0009","ix":10,"v":{"a":0,"k":1,"ix":10}},{"ty":0,"nm":"Shutter Angle","mn":"ADBE Geometry2-0010","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":7,"nm":"Sampling","mn":"ADBE Geometry2-0012","ix":12,"v":{"a":0,"k":1,"ix":12}}]}],"w":300,"h":300,"ip":0,"op":72,"st":0,"bm":0},{"ddd":0,"ind":3,"ty":4,"nm":"circle_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[250,250,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ef":[{"ty":5,"nm":"Extrudalizer","np":70,"mn":"Pseudo/Extrudalizer","ix":1,"en":1,"ef":[{"ty":6,"nm":"3D Transform","mn":"Pseudo/Extrudalizer-0001","ix":1,"v":0},{"ty":0,"nm":"Extrusion depth","mn":"Pseudo/Extrudalizer-0002","ix":2,"v":{"a":0,"k":30,"ix":2}},{"ty":3,"nm":"Position","mn":"Pseudo/Extrudalizer-0003","ix":3,"v":{"a":0,"k":[0,0,0],"ix":3}},{"ty":6,"nm":"Scale","mn":"Pseudo/Extrudalizer-0004","ix":4,"v":0},{"ty":0,"nm":"Front scale","mn":"Pseudo/Extrudalizer-0005","ix":5,"v":{"a":0,"k":100,"ix":5}},{"ty":0,"nm":"Back scale","mn":"Pseudo/Extrudalizer-0006","ix":6,"v":{"a":0,"k":100,"ix":6}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0007","ix":7,"v":0},{"ty":6,"nm":"Pitch/Roll/Yaw","mn":"Pseudo/Extrudalizer-0008","ix":8,"v":0},{"ty":0,"nm":"Pitch (x)","mn":"Pseudo/Extrudalizer-0009","ix":9,"v":{"a":1,"k":[{"i":{"x":[0.246],"y":[0.944]},"o":{"x":[0.183],"y":[0.026]},"t":0,"s":[0]},{"i":{"x":[0.044],"y":[1.033]},"o":{"x":[0.257],"y":[-0.01]},"t":4,"s":[-35]},{"t":71,"s":[1080]}],"ix":9}},{"ty":0,"nm":"Yaw (y)","mn":"Pseudo/Extrudalizer-0010","ix":10,"v":{"a":0,"k":0,"ix":10}},{"ty":0,"nm":"Roll (z)","mn":"Pseudo/Extrudalizer-0011","ix":11,"v":{"a":0,"k":0,"ix":11}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0012","ix":12,"v":0},{"ty":6,"nm":"Orbit control","mn":"Pseudo/Extrudalizer-0013","ix":13,"v":0},{"ty":0,"nm":"X Rotation","mn":"Pseudo/Extrudalizer-0014","ix":14,"v":{"a":0,"k":0,"ix":14}},{"ty":0,"nm":"Y Rotation","mn":"Pseudo/Extrudalizer-0015","ix":15,"v":{"a":0,"k":0,"ix":15}},{"ty":0,"nm":"Z Rotation","mn":"Pseudo/Extrudalizer-0016","ix":16,"v":{"a":0,"k":0,"ix":16}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0017","ix":17,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0018","ix":18,"v":0},{"ty":6,"nm":"Appearance","mn":"Pseudo/Extrudalizer-0019","ix":19,"v":0},{"ty":7,"nm":"Hide anchor point","mn":"Pseudo/Extrudalizer-0020","ix":20,"v":{"a":0,"k":0,"ix":20}},{"ty":7,"nm":"Wireframe mode","mn":"Pseudo/Extrudalizer-0021","ix":21,"v":{"a":0,"k":0,"ix":21}},{"ty":2,"nm":"Edge stroke color","mn":"Pseudo/Extrudalizer-0022","ix":22,"v":{"a":0,"k":[0.134640440345,0.134640440345,0.134640440345,1],"ix":22}},{"ty":0,"nm":"Edge stroke width","mn":"Pseudo/Extrudalizer-0023","ix":23,"v":{"a":0,"k":2,"ix":23}},{"ty":0,"nm":"Translucency","mn":"Pseudo/Extrudalizer-0024","ix":24,"v":{"a":0,"k":0,"ix":24}},{"ty":6,"nm":"Front & Back ","mn":"Pseudo/Extrudalizer-0025","ix":25,"v":0},{"ty":2,"nm":"Front color","mn":"Pseudo/Extrudalizer-0026","ix":26,"v":{"a":0,"k":[0,1,1,1],"ix":26}},{"ty":0,"nm":"Front opacity","mn":"Pseudo/Extrudalizer-0027","ix":27,"v":{"a":0,"k":100,"ix":27}},{"ty":0,"nm":"Front gradient opacity","mn":"Pseudo/Extrudalizer-0028","ix":28,"v":{"a":0,"k":0,"ix":28}},{"ty":0,"nm":"Front gradient direction","mn":"Pseudo/Extrudalizer-0029","ix":29,"v":{"a":0,"k":0,"ix":29}},{"ty":6,"nm":"   ","mn":"Pseudo/Extrudalizer-0030","ix":30,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0031","ix":31,"v":0},{"ty":2,"nm":"Back color","mn":"Pseudo/Extrudalizer-0032","ix":32,"v":{"a":0,"k":[0,1,1,1],"ix":32}},{"ty":0,"nm":"Back opacity","mn":"Pseudo/Extrudalizer-0033","ix":33,"v":{"a":0,"k":100,"ix":33}},{"ty":0,"nm":"Back gradient opacity","mn":"Pseudo/Extrudalizer-0034","ix":34,"v":{"a":0,"k":0,"ix":34}},{"ty":0,"nm":"Back gradient direction","mn":"Pseudo/Extrudalizer-0035","ix":35,"v":{"a":0,"k":0,"ix":35}},{"ty":6,"nm":"    ","mn":"Pseudo/Extrudalizer-0036","ix":36,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0037","ix":37,"v":0},{"ty":3,"nm":"Gradient start point","mn":"Pseudo/Extrudalizer-0038","ix":38,"v":{"a":0,"k":[0,0],"ix":38}},{"ty":3,"nm":"Gradient end point","mn":"Pseudo/Extrudalizer-0039","ix":39,"v":{"a":0,"k":[0,0],"ix":39}},{"ty":6,"nm":"Edit gradient start/end points ","mn":"Pseudo/Extrudalizer-0040","ix":40,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0041","ix":41,"v":0},{"ty":6,"nm":"at 3D rotation set to [0,0,0]","mn":"Pseudo/Extrudalizer-0042","ix":42,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0043","ix":43,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0044","ix":44,"v":0},{"ty":6,"nm":"Sides","mn":"Pseudo/Extrudalizer-0045","ix":45,"v":0},{"ty":2,"nm":"Sides color","mn":"Pseudo/Extrudalizer-0046","ix":46,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":46}},{"ty":0,"nm":"Sides opacity","mn":"Pseudo/Extrudalizer-0047","ix":47,"v":{"a":0,"k":100,"ix":47}},{"ty":0,"nm":"Sides gradient opacity","mn":"Pseudo/Extrudalizer-0048","ix":48,"v":{"a":0,"k":0,"ix":48}},{"ty":0,"nm":"Sides gradient direction","mn":"Pseudo/Extrudalizer-0049","ix":49,"v":{"a":0,"k":0,"ix":49}},{"ty":0,"nm":"Sides gradient length","mn":"Pseudo/Extrudalizer-0050","ix":50,"v":{"a":0,"k":0,"ix":50}},{"ty":2,"nm":"Sides fill shadow color","mn":"Pseudo/Extrudalizer-0051","ix":51,"v":{"a":0,"k":[0,0,0,1],"ix":51}},{"ty":0,"nm":"Sides fill shadow opacity","mn":"Pseudo/Extrudalizer-0052","ix":52,"v":{"a":0,"k":0,"ix":52}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0053","ix":53,"v":0},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0054","ix":54,"v":0},{"ty":6,"nm":"Parenting Data","mn":"Pseudo/Extrudalizer-0055","ix":55,"v":0},{"ty":0,"nm":"Front opacity readout","mn":"Pseudo/Extrudalizer-0056","ix":56,"v":{"a":0,"k":100,"ix":56,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":0,"nm":"Back opacity readout","mn":"Pseudo/Extrudalizer-0057","ix":57,"v":{"a":0,"k":100,"ix":57,"x":"var $bm_rt;\ntry {\n    $bm_rt = content('--- EXTRUDALIZER ---').content('BACK').transform.opacity;\n} catch (e) {\n    $bm_rt = 0;\n}"}},{"ty":7,"nm":"Compute 3D front bounding box","mn":"Pseudo/Extrudalizer-0058","ix":58,"v":{"a":0,"k":1,"ix":58}},{"ty":3,"nm":"Front upper left","mn":"Pseudo/Extrudalizer-0059","ix":59,"v":{"a":0,"k":[0,0],"ix":59,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[0],\n            front_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front upper right","mn":"Pseudo/Extrudalizer-0060","ix":60,"v":{"a":0,"k":[0,0],"ix":60,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[2],\n            front_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower left","mn":"Pseudo/Extrudalizer-0061","ix":61,"v":{"a":0,"k":[0,0],"ix":61,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[4],\n            front_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Front lower right","mn":"Pseudo/Extrudalizer-0062","ix":62,"v":{"a":0,"k":[0,0],"ix":62,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D front bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let front_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        front_bb = extr_data_arr[14];\n        $bm_rt = front_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_bb = extr_data_arr[14].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            front_bb[6],\n            front_bb[7]\n        ];\n    }\n}"}},{"ty":7,"nm":"Compute 3D back bounding box","mn":"Pseudo/Extrudalizer-0063","ix":63,"v":{"a":0,"k":1,"ix":63}},{"ty":3,"nm":"Back upper left","mn":"Pseudo/Extrudalizer-0064","ix":64,"v":{"a":0,"k":[0,0],"ix":64,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[0];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[0],\n            back_bb[1]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back upper right","mn":"Pseudo/Extrudalizer-0065","ix":65,"v":{"a":0,"k":[0,0],"ix":65,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[1];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[2],\n            back_bb[3]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower left","mn":"Pseudo/Extrudalizer-0066","ix":66,"v":{"a":0,"k":[0,0],"ix":66,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[2];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[4],\n            back_bb[5]\n        ];\n    }\n}"}},{"ty":3,"nm":"Back lower right","mn":"Pseudo/Extrudalizer-0067","ix":67,"v":{"a":0,"k":[0,0],"ix":67,"x":"var $bm_rt;\n'use native operators';\nconst use_bb = effect('Extrudalizer')('Compute 3D back bounding box').value;\nif (!use_bb) {\n    $bm_rt = [\n        0,\n        0\n    ];\n} else {\n    let extr_data_arr;\n    let back_bb;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        back_bb = extr_data_arr[15];\n        $bm_rt = back_bb[3];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        back_bb = extr_data_arr[15].split(',').map(s => parseFloat(s));\n        $bm_rt = [\n            back_bb[6],\n            back_bb[7]\n        ];\n    }\n}"}},{"ty":6,"nm":"Extrudalizer","mn":"Pseudo/Extrudalizer-0068","ix":68,"v":0}]},{"ty":5,"nm":"FACE 0","np":3,"mn":"ADBE Color Control","ix":2,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 1","np":3,"mn":"ADBE Color Control","ix":3,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 2","np":3,"mn":"ADBE Color Control","ix":4,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 3","np":3,"mn":"ADBE Color Control","ix":5,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 4","np":3,"mn":"ADBE Color Control","ix":6,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 5","np":3,"mn":"ADBE Color Control","ix":7,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 6","np":3,"mn":"ADBE Color Control","ix":8,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 7","np":3,"mn":"ADBE Color Control","ix":9,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 8","np":3,"mn":"ADBE Color Control","ix":10,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 9","np":3,"mn":"ADBE Color Control","ix":11,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 10","np":3,"mn":"ADBE Color Control","ix":12,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 11","np":3,"mn":"ADBE Color Control","ix":13,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 12","np":3,"mn":"ADBE Color Control","ix":14,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 13","np":3,"mn":"ADBE Color Control","ix":15,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 14","np":3,"mn":"ADBE Color Control","ix":16,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 15","np":3,"mn":"ADBE Color Control","ix":17,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 16","np":3,"mn":"ADBE Color Control","ix":18,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 17","np":3,"mn":"ADBE Color Control","ix":19,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 18","np":3,"mn":"ADBE Color Control","ix":20,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]},{"ty":5,"nm":"FACE 19","np":3,"mn":"ADBE Color Control","ix":21,"en":1,"ef":[{"ty":2,"nm":"Color","mn":"ADBE Color Control-0001","ix":1,"v":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":1}}]}],"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[[-82.843,0],[0,-82.843],[82.843,0],[0,82.843]],"o":[[82.843,0],[0,82.843],[-82.843,0],[0,-82.843]],"v":[[0,-150],[150,0],[0,150],[-150,0]],"c":true},"ix":2},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":true},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":0,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[10,10],"ix":2},"p":{"a":0,"k":[0,0],"ix":3},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse","hd":false},{"ty":"fl","c":{"a":0,"k":[1,0,0,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ANCHOR POINT","np":2,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    points_3D = extr_data_arr[5];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0,0,0,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4,"x":"var $bm_rt;\nvar dot_, adjustColorBrightness;\n'use native operators';\nlet color;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    color = [\n        0,\n        0,\n        0,\n        0\n    ];\n} else {\n    dot_ = function (a, b) {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    };\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    const side_shadow_opacity_max = effect('Extrudalizer')('Sides fill shadow opacity').value;\n    const rgba = effect('Extrudalizer')('Front color').value;\n    let extr_data_arr;\n    let front_normal = [];\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        front_normal = extr_data_arr[13];\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        front_normal = extr_data_arr[13].split(',').map(p => parseFloat(p));\n    }\n    const dark_coeff = 2;\n    var brightness = $bm_div($bm_mul($bm_mul(dark_coeff, $bm_sub(100, side_shadow_opacity_max)), Math.abs(dot_(front_normal, [\n        0,\n        0,\n        1\n    ]))), 100);\n    color = adjustColorBrightness(rgba, brightness);\n}\n$bm_rt = color;"},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet is_facing_towards_us;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    is_facing_towards_us = extr_data_arr[8] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    is_facing_towards_us = extr_data_arr[8] === 'true';\n}\nconst depth = effect('Extrudalizer')('Extrusion depth').value;\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = $bm_div(effect('Extrudalizer')('Translucency').value, 2);\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    if (is_facing_towards_us > 0) {\n        $bm_rt = opacity_value;\n    } else {\n        $bm_rt = transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"FRONT","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nlet extr_data_arr;\nlet points_3D = [];\nlet isPathClosed;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    points_3D = extr_data_arr[6];\n    isPathClosed = extr_data_arr[4] === true;\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let points_arr = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    isPathClosed = extr_data_arr[4] === 'true';\n    for (var i = 0, il = points_arr.length / 3; i < il; i++) {\n        points_3D.push(points_arr.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst points_2D = points_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst num_pts = points_2D.length;\nconst zeroArr = Array(num_pts).fill([\n    0,\n    0\n]);\n$bm_rt = createPath(points_2D, zeroArr, zeroArr, isPathClosed);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.141176477075,0.141176477075,0.141176477075,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.941176533699,0.639215707779,0.239215701818,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nif (isWireframe) {\n    $bm_rt = value = 0;\n} else {\n    try {\n        const frontOpacity = content('--- EXTRUDALIZER ---').content('FRONT').transform.opacity.value;\n        $bm_rt = value = $bm_sub(100, frontOpacity);\n    } catch (e) {\n        $bm_rt = 100;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"BACK","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 0;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.13987604777,0.141164487951,0.142483580346,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 0;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 0 - 1","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 1;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.13987604777,0.141164487951,0.142483580346,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 1;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 1 - 2","np":3,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 2;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.13987604777,0.141164487951,0.142483580346,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 2;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 2 - 3","np":3,"cix":2,"bm":0,"ix":3,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 3;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.139876052737,0.14116448164,0.142483577132,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 3;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 3 - 4","np":3,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 4;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.13987604777,0.141164487951,0.142483580346,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 4;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 4 - 5","np":3,"cix":2,"bm":0,"ix":5,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 5;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.13987604777,0.141164487951,0.142483580346,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 5;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 5 - 6","np":3,"cix":2,"bm":0,"ix":6,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 6;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.13987604777,0.141164487951,0.142483580346,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 6;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 6 - 7","np":3,"cix":2,"bm":0,"ix":7,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 7;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.13987604777,0.141164487951,0.142483580346,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 7;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 7 - 8","np":3,"cix":2,"bm":0,"ix":8,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 8;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 8;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 8 - 9","np":3,"cix":2,"bm":0,"ix":9,"mn":"ADBE Vector Group","hd":false},{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\n'use native operators';\nconst side_index = 9;\nlet extr_data_arr;\nlet srt_ind = [];\nlet points_front_3D = [];\nlet points_back_3D = [];\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    srt_ind = extr_data_arr[7];\n    points_front_3D = extr_data_arr[5];\n    points_back_3D = extr_data_arr[6];\n} catch (err) {\n    const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    let sorted_indices = extr_data_arr[7].split(',').map(p => parseInt(p));\n    let front_points_3D = extr_data_arr[5].split(',').map(s => parseFloat(s));\n    let back_points_3D = extr_data_arr[6].split(',').map(s => parseFloat(s));\n    for (var i = 0, il = sorted_indices.length / 2; i < il; i++) {\n        srt_ind.push(sorted_indices.slice($bm_mul(2, i), $bm_sum($bm_mul(2, i), 2)));\n    }\n    for (var i = 0, il = front_points_3D.length / 3; i < il; i++) {\n        points_front_3D.push(front_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n        points_back_3D.push(back_points_3D.slice($bm_mul(3, i), $bm_sum($bm_mul(3, i), 3)));\n    }\n}\nconst currentIndex = srt_ind[side_index][0];\nconst nextIndex = srt_ind[side_index][1];\nconst points_front_2D = points_front_3D.map(v => [\n    v[0],\n    v[1]\n]);\nconst points_back_2D = points_back_3D.map(v => [\n    v[0],\n    v[1]\n]);\n$bm_rt = createPath([\n    points_front_2D[nextIndex],\n    points_front_2D[currentIndex],\n    points_back_2D[currentIndex],\n    points_back_2D[nextIndex]\n]);"},"nm":"Path 1","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":2,"ix":5},"lc":1,"lj":2,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[0.939869344234,0.640527307987,0.23957452178,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7,"x":"var $bm_rt;\n'use native operators';\nconst isWireframe = effect('Extrudalizer')('Wireframe mode').value;\nconst transparency_value = effect('Extrudalizer')('Translucency').value;\nconst opacity_value = $bm_sub(100, transparency_value);\nif (isWireframe) {\n    $bm_rt = value = 100;\n} else {\n    let extr_data_arr;\n    let isPathClosed;\n    try {\n        _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n        extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n        $bm_rt = isPathClosed = extr_data_arr[4] === true;\n    } catch (err) {\n        const extr_data = thisComp.layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n        extr_data_arr = extr_data.split(';');\n        $bm_rt = isPathClosed = extr_data_arr[4] === 'true';\n    }\n    if (!isPathClosed) {\n        $bm_rt = value = opacity_value;\n    } else {\n        const side_index = 9;\n        const num_facing_sides = extr_data_arr[10];\n        $bm_rt = value = side_index <= $bm_sub(num_facing_sides, 1) ? opacity_value : transparency_value;\n    }\n}"},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDE 9 - 10","np":3,"cix":2,"bm":0,"ix":10,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"SIDES","np":10,"cix":2,"bm":0,"ix":4,"mn":"ADBE Vector Group","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"--- EXTRUDALIZER ---","np":4,"cix":2,"bm":0,"ix":2,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":72,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":4,"ty":5,"nm":"EXTRUDALIZER DATA || circle_1","hd":true,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[250,250,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"t":{"d":{"k":[{"s":{"s":90,"f":"Montserrat-Black","t":"","ca":1,"j":0,"tr":1000,"lh":108.000007629395,"ls":11,"fc":[1,1,1]},"t":0}],"x":"var $bm_rt;\nvar dot_, cross_vec, len_vec, arraysEqual, getNormal, get2D_projection, getBoundingBox, getPositionMatrix, getRotationMatrix, getScaleMatrix, getIdentity, translate, rotateX, rotateY, rotateZ, multiplyMatrixVector, multiplyMatrices, multiplyArrayOfMatrices, transformMatrix, make_transform, getPoint, getArea, isClockwise, getCentroid, hasNoneZeroValues, angle_between, angle_between_cw, angle_between_cw_te, isStraightLine_w_delta, isFacingTowardsUs, isVectorFacingTowardsUs, multiplyMatrixVector3x3, multiplyArrayOfMatrices3x3, multiplyMatrices3x3, transform2D_apply, get_transform_shape_matrix, get_transforms_from_bb, num_pts, compare_sides, sorted_sides_indices, adjustColorBrightness, lambertShader, stringify;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\ncross_vec = function (a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\narraysEqual = function (arr1, arr2) {\n    for (var i = 0, il = arr1.length; i < il; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n};\ngetNormal = function (pts, normalized) {\n    let dir = cross_vec(sub(pts[1], pts[0]), sub(pts[2], pts[0]));\n    let len_dir = len_vec(dir);\n    if (len_dir === 0) {\n        return [\n            0,\n            0,\n            0\n        ];\n    }\n    if (normalized) {\n        return div(dir, len_dir);\n    } else {\n        return dir;\n    }\n};\nget2D_projection = function (points) {\n    return points.map(v => [\n        v[0],\n        v[1]\n    ]);\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    boundingBox.left_top = [\n        boundingBox.left,\n        boundingBox.top\n    ];\n    boundingBox.left_bottom = [\n        boundingBox.left,\n        boundingBox.bottom\n    ];\n    boundingBox.right_top = [\n        boundingBox.right,\n        boundingBox.top\n    ];\n    boundingBox.right_bottom = [\n        boundingBox.right,\n        boundingBox.bottom\n    ];\n    return boundingBox;\n};\ngetPositionMatrix = function (value) {\n    return translate(getIdentity(), value[0], value[1], $bm_neg(value[2]));\n};\ngetRotationMatrix = function (angles) {\n    const angleX = angles[0];\n    const angleY = angles[1];\n    const angleZ = angles[2];\n    var matrix = getIdentity();\n    matrix = rotateZ(matrix, $bm_div($bm_mul(angleZ, Math.PI), 180));\n    matrix = rotateY(matrix, $bm_div($bm_mul(angleY, Math.PI), 180));\n    matrix = rotateX(matrix, $bm_div($bm_mul(angleX, Math.PI), 180));\n    return matrix;\n};\ngetScaleMatrix = function (sc) {\n    return [\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        sc,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ngetIdentity = function () {\n    return [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ];\n};\ntranslate = function (matrix, x, y, z) {\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        x,\n        0,\n        1,\n        0,\n        y,\n        0,\n        0,\n        1,\n        z,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateX = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        1,\n        0,\n        0,\n        0,\n        0,\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateY = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        0,\n        sin_th,\n        0,\n        0,\n        1,\n        0,\n        0,\n        $bm_neg(sin_th),\n        0,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nrotateZ = function (matrix, theta) {\n    const cos_th = Math.cos(theta), sin_th = Math.sin(theta);\n    return multiplyMatrices(matrix, [\n        cos_th,\n        $bm_neg(sin_th),\n        0,\n        0,\n        sin_th,\n        cos_th,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n    ]);\n};\nmultiplyMatrixVector = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 4; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 4; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 4), j)], vector[j]));\n        }\n    }\n    return result;\n};\nmultiplyMatrices = function (matrixB, matrixA) {\n    let result = new Array(16).fill(0);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            for (let k = 0; k < 4; k++) {\n                result[$bm_sum($bm_mul(i, 4), j)] = $bm_sum(result[$bm_sum($bm_mul(i, 4), j)], $bm_mul(matrixA[$bm_sum($bm_mul(i, 4), k)], matrixB[$bm_sum($bm_mul(k, 4), j)]));\n            }\n        }\n    }\n    return result;\n};\nmultiplyArrayOfMatrices = function (matrices) {\n    var result = matrices[0];\n    for (var i = 1, il = matrices.length; i < il; i++) {\n        result = multiplyMatrices(result, matrices[i]);\n    }\n    return result;\n};\ntransformMatrix = function (move, sc, pivot, pitch_angles, anch, orbit_angles) {\n    var mat_array = [];\n    if (sc !== 1) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getScaleMatrix(sc),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getScaleMatrix(sc));\n        }\n    }\n    mat_array.push(getPositionMatrix(move));\n    if (!arraysEqual(pitch_angles, [\n            0,\n            0,\n            0\n        ])) {\n        if (!arraysEqual(pivot, [\n                0,\n                0,\n                0\n            ])) {\n            mat_array = mat_array.concat([\n                getPositionMatrix(pivot.map(i => -i)),\n                getRotationMatrix(pitch_angles),\n                getPositionMatrix(pivot)\n            ]);\n        } else {\n            mat_array.push(getRotationMatrix(pitch_angles));\n        }\n    }\n    if (!arraysEqual(anch, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getPositionMatrix(anch.map(i => -i)));\n    }\n    if (!arraysEqual(orbit_angles, [\n            0,\n            0,\n            0\n        ])) {\n        mat_array.push(getRotationMatrix(orbit_angles));\n    }\n    return multiplyArrayOfMatrices(mat_array);\n};\nmake_transform = function (transform_matrix, vector) {\n    if (vector.length == 2) {\n        vector = [\n            ...vector,\n            0,\n            1\n        ];\n    } else if (vector.length == 3) {\n        vector = [\n            ...vector,\n            1\n        ];\n    }\n    var result_vector_4d = multiplyMatrixVector(transform_matrix, vector);\n    return result_vector_4d.slice(0, 3);\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetArea = function (points) {\n    var area = 0;\n    for (var i = 0, il = points.length; i < il; i++) {\n        var p1 = points[i];\n        var p2 = points[(i + 1) % il];\n        area = $bm_sum(area, $bm_sub($bm_mul(p1[0], p2[1]), $bm_mul(p2[0], p1[1])));\n    }\n    return $bm_div(area, 2);\n};\nisClockwise = function (points) {\n    return getArea(points) > 0;\n};\ngetCentroid = function (vertices) {\n    var area = getArea(vertices);\n    if (area === 0) {\n        function findCenter(points) {\n            let sumX = 0;\n            let sumY = 0;\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                sumX = $bm_sum(sumX, point[0]);\n                sumY = $bm_sum(sumY, point[1]);\n            }\n            const meanX = $bm_div(sumX, points.length);\n            const meanY = $bm_div(sumY, points.length);\n            return [\n                meanX,\n                meanY\n            ];\n        }\n        return findCenter(vertices);\n    }\n    let centroidX = 0;\n    let centroidY = 0;\n    const numVertices = vertices.length;\n    for (var i = 0; i < numVertices; i++) {\n        var currentVertex = vertices[i];\n        var nextVertex = vertices[(i + 1) % numVertices];\n        var commonFactor = $bm_sub($bm_mul(currentVertex[0], nextVertex[1]), $bm_mul(nextVertex[0], currentVertex[1]));\n        centroidX = $bm_sum(centroidX, $bm_mul($bm_sum(currentVertex[0], nextVertex[0]), commonFactor));\n        centroidY = $bm_sum(centroidY, $bm_mul($bm_sum(currentVertex[1], nextVertex[1]), commonFactor));\n    }\n    var scaleFactor = $bm_div(1, $bm_mul(6, area));\n    centroidX *= scaleFactor;\n    centroidY *= scaleFactor;\n    return [\n        centroidX,\n        centroidY\n    ];\n};\nhasNoneZeroValues = function (array2D) {\n    return array2D.some(array => array.some(value => value !== 0));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nangle_between_cw = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    angle = angle >= 0 ? angle : $bm_sum($bm_mul(2, Math.PI), angle);\n    const degrees = $bm_mul(angle, $bm_div(180, Math.PI));\n    return degrees;\n};\nangle_between_cw_te = function (u, v) {\n    const dotProduct = $bm_sum($bm_mul(u[0], v[0]), $bm_mul(u[1], v[1]));\n    const crossProduct = $bm_sub($bm_mul(u[0], v[1]), $bm_mul(u[1], v[0]));\n    let angle = Math.atan2(crossProduct, dotProduct);\n    const degrees = $bm_mul($bm_neg(angle), $bm_div(180, Math.PI));\n    return degrees;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\nisFacingTowardsUs = function (p1, p2) {\n    return dot_(sub(p2, p1), [\n        0,\n        0,\n        1\n    ]) > 0;\n};\nisVectorFacingTowardsUs = function (v) {\n    return dot_(v, [\n        0,\n        0,\n        -1\n    ]) > 0;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nget_transform_shape_matrix = function (anchor, pos, scale, rot, skew, skew_axis) {\n    let mat_array = [];\n    if (anchor[0] !== 0 || anchor[1] !== 0) {\n        const A = [\n            1,\n            0,\n            -anchor[0],\n            0,\n            1,\n            -anchor[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(A);\n    }\n    if (scale[0] !== 100 || scale[1] !== 100) {\n        const S = [\n            scale[0] / 100,\n            0,\n            0,\n            0,\n            scale[1] / 100,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(S);\n    }\n    if (skew !== 0) {\n        const sk_angle = $bm_div($bm_mul(skew, Math.PI), 180);\n        const Sk = [\n            1,\n            Math.tan(-sk_angle),\n            0,\n            0,\n            1,\n            0,\n            0,\n            0,\n            1\n        ];\n        if (skew_axis !== 0) {\n            const sk_axis_angle = $bm_div($bm_mul(skew_axis, Math.PI), 180);\n            const cos_sk = Math.cos(sk_axis_angle);\n            const sin_sk = Math.sin(sk_axis_angle);\n            const Rz = [\n                cos_sk,\n                -sin_sk,\n                0,\n                sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const Rz_inv = [\n                cos_sk,\n                sin_sk,\n                0,\n                -sin_sk,\n                cos_sk,\n                0,\n                0,\n                0,\n                1\n            ];\n            const SkM = multiplyArrayOfMatrices3x3([\n                Rz_inv,\n                Sk,\n                Rz\n            ]);\n            mat_array.push(SkM);\n        } else {\n            mat_array.push(Sk);\n        }\n    }\n    if (rot !== 0) {\n        const theta = $bm_div($bm_mul(rot, Math.PI), 180);\n        const cos_th = Math.cos(theta);\n        const sin_th = Math.sin(theta);\n        const R = [\n            cos_th,\n            -sin_th,\n            0,\n            sin_th,\n            cos_th,\n            0,\n            0,\n            0,\n            1\n        ];\n        mat_array.push(R);\n    }\n    if (pos[0] !== 0 || pos[1] !== 0) {\n        const T = [\n            1,\n            0,\n            pos[0],\n            0,\n            1,\n            pos[1],\n            0,\n            0,\n            1\n        ];\n        mat_array.push(T);\n    }\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\nget_transforms_from_bb = function (bb, extr_transform_matrix, layer_transform_matrix, parent_transform_matrix, is_front, front_facing_towards_us, mode) {\n    let bb_transformed_3D = [];\n    if (front_facing_towards_us) {\n        bb_transformed_3D = [\n            bb.left_top,\n            bb.right_top,\n            bb.left_bottom,\n            bb.right_bottom\n        ];\n    } else {\n        bb_transformed_3D = [\n            bb.right_top,\n            bb.left_top,\n            bb.right_bottom,\n            bb.left_bottom\n        ];\n    }\n    bb_transformed_3D = bb_transformed_3D.map(pnt => make_transform(extr_transform_matrix, pnt));\n    let bb_transformed_2D = get2D_projection(bb_transformed_3D);\n    bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(layer_transform_matrix, p));\n    if (parent_transform_matrix) {\n        bb_transformed_2D = bb_transformed_2D.map(p => transform2D_apply(parent_transform_matrix, p));\n    }\n    const ex_left_top = bb_transformed_2D[0], ex_right_top = bb_transformed_2D[1], ex_left_bottom = bb_transformed_2D[2], ex_right_bottom = bb_transformed_2D[3];\n    let transform_effect_controls = [];\n    if (mode & 1) {\n        const bb_pos = ex_left_top;\n        const ex_AD = sub(ex_left_bottom, ex_left_top);\n        const rot = angle_between_cw_te(ex_AD, [\n            0,\n            1\n        ]);\n        const ex_AB = sub(ex_right_top, ex_left_top);\n        const rot_rad = $bm_mul(rot, $bm_div(Math.PI, 180));\n        const x_rot = [\n            Math.cos(rot_rad),\n            Math.sin(rot_rad)\n        ];\n        let skw = angle_between_cw_te(ex_AB, x_rot);\n        if (!front_facing_towards_us) {\n            skw = skw > 90 ? $bm_sub(skw, 180) : skw;\n            skw = skw <= -90 ? $bm_sum(skw, 180) : skw;\n        }\n        ;\n        let extra_skew_arr = [];\n        if (Math.abs(skw) > 70) {\n            const max_count = 7;\n            let count = 1;\n            let skew_ = Math.abs(skw);\n            const tan_70 = Math.tan(degreesToRadians(70));\n            while (skew_ > 70 && count < max_count) {\n                skew_ = radiansToDegrees(Math.atan($bm_sub(Math.tan(degreesToRadians(skew_)), tan_70)));\n                extra_skew_arr.push(skw > 0 ? skew_ : -skew_);\n                count++;\n            }\n        }\n        const scaleY = $bm_mul(100, len_vec(ex_AD));\n        const angle_AB_AD = angle_between_cw_te(ex_AD, ex_AB);\n        const beta = $bm_sub($bm_sub(180, angle_AB_AD), skw);\n        const scaleX_coeff = $bm_div(Math.sin($bm_div($bm_mul(beta, Math.PI), 180)), Math.sin($bm_div($bm_mul(angle_AB_AD, Math.PI), 180)));\n        let scaleX = $bm_div($bm_mul(100, len_vec(ex_AB)), scaleX_coeff);\n        if (!front_facing_towards_us) {\n            scaleX = $bm_neg(scaleX);\n        }\n        transform_effect_controls = [\n            bb_pos,\n            rot,\n            skw,\n            scaleY,\n            scaleX,\n            extra_skew_arr\n        ];\n    }\n    let transform_layer_controls = [];\n    if (mode & 2) {\n        const tl_AB = sub(bb.right_top, bb.left_top);\n        const tl_AD = sub(bb.left_bottom, bb.left_top);\n        const tl_scaleX_coeff = 100;\n        const tl_scaleY_coeff = 100;\n        const tl_bb_anchor = bb.left_top;\n        let tl_bb_pos = ex_left_top;\n        const tl_ex_AB = sub(ex_right_top, ex_left_top);\n        let tl_bb_theta = angle_between_cw(tl_AB, tl_ex_AB);\n        let tl_bb_scx = $bm_div($bm_mul(tl_scaleX_coeff, len_vec(tl_ex_AB)), len_vec(tl_AB));\n        const tl_ex_AD = sub(ex_left_bottom, ex_left_top);\n        const tl_bb_th_rad = $bm_mul(tl_bb_theta, $bm_div(Math.PI, 180));\n        const tl_cos_th = Math.cos(tl_bb_th_rad);\n        const tl_sin_th = Math.sin(tl_bb_th_rad);\n        const tl_AD_rot = [\n            tl_AD[0] * tl_cos_th - tl_AD[1] * tl_sin_th,\n            tl_AD[0] * tl_sin_th + tl_AD[1] * tl_cos_th\n        ];\n        let tl_skew = angle_between_cw(tl_AD_rot, tl_ex_AD);\n        tl_skew = tl_skew < 90 ? tl_skew : $bm_sub(tl_skew, 360);\n        const tl_sk_rad = $bm_div($bm_mul(tl_skew, Math.PI), 180);\n        const tl_AD_skew = [\n            tl_AD[0] + Math.tan(-tl_sk_rad) * tl_AD[1],\n            tl_AD[1]\n        ];\n        const tl_bb_scy = $bm_div($bm_mul(tl_scaleY_coeff, len_vec(tl_ex_AD)), len_vec(tl_AD_skew));\n        if (front_facing_towards_us && !is_front || !front_facing_towards_us && is_front) {\n            tl_bb_scx = $bm_neg(tl_bb_scx);\n            tl_bb_pos = $bm_sum(tl_bb_pos, tl_ex_AB);\n        }\n        transform_layer_controls = [\n            tl_bb_anchor[0],\n            tl_bb_anchor[1],\n            tl_bb_pos[0],\n            tl_bb_pos[1],\n            tl_bb_theta,\n            tl_bb_scx,\n            tl_bb_scy,\n            tl_skew\n        ];\n    }\n    return {\n        'boundingBoxTransformed': bb_transformed_2D,\n        'transformEffectControls': transform_effect_controls,\n        'transformLayerControls': transform_layer_controls\n    };\n};\nconst shape_layer = thisComp.layer('circle_1');\nconst shape = shape_layer(2)(1);\nconst shape_contents = shape(2);\nconst targetPath = shape_contents(1)(2);\nconst is_path_closed = targetPath.isClosed();\nconst extrudalizer = shape_layer('ADBE Effect Parade')('Pseudo/Extrudalizer');\nconst depth = extrudalizer('Extrusion depth').value;\nlet anchor = extrudalizer('Position').value;\nanchor = [\n    $bm_neg(anchor[0]),\n    anchor[1],\n    anchor[2]\n];\nconst angleX = extrudalizer('X Rotation').value;\nconst angleY = extrudalizer('Y Rotation').value;\nconst angleZ = extrudalizer('Z Rotation').value;\nconst pivot_angleX = extrudalizer('Pitch (x)').value;\nconst pivot_angleY = extrudalizer('Yaw (y)').value;\nconst pivot_angleZ = extrudalizer('Roll (z)').value;\nconst scale_front = $bm_div(extrudalizer('Front scale').value, 100);\nconst scale_back = $bm_div(extrudalizer('Back scale').value, 100);\nconst use_bb_front = extrudalizer('Compute 3D front bounding box').value;\nconst use_bb_back = extrudalizer('Compute 3D back bounding box').value;\nlet pnts = targetPath.points();\nlet inTangents = targetPath.inTangents();\nlet outTangents = targetPath.outTangents();\nconst is_front_clockwise = isClockwise(pnts);\nconst shape_transform = shape.transform;\nconst s_anchor = shape_transform.anchorPoint;\nconst s_pos = shape_transform.position;\nconst s_scale = shape_transform.scale;\nconst s_rot = shape_transform.rotation;\nconst s_skew = shape_transform.skew;\nconst s_skew_axis = shape_transform.skewAxis;\nconst shape_transform_matrix = get_transform_shape_matrix(s_anchor, s_pos, s_scale, s_rot, s_skew, s_skew_axis);\nconst layer_transform = shape_layer.transform;\nconst l_anchor = layer_transform.anchorPoint;\nconst l_pos = layer_transform.position;\nconst l_scale = layer_transform.scale;\nconst l_rot = layer_transform.rotation;\nconst layer_transform_matrix = get_transform_shape_matrix(l_anchor, l_pos, l_scale, l_rot, 0, 0);\nlet subdivs = 1;\nlet num_pnts = pnts.length;\nif (hasNoneZeroValues(inTangents) || hasNoneZeroValues(outTangents)) {\n    subdivs = 5;\n    let pointsF = [];\n    var end_of_cycle = is_path_closed ? num_pnts : $bm_sub(num_pnts, 1);\n    for (var i = 0; i < num_pnts; i++) {\n        pointsF.push(pnts[i]);\n        if (!is_path_closed && i == num_pnts - 1) {\n            break;\n        }\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n            }\n        }\n    }\n    pnts = pointsF;\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\nnum_pts = pnts.length;\nconst zero_center_point = getCentroid(pnts);\nconst zero_center_point_3D = [\n    ...zero_center_point,\n    0\n];\nconst tr_front_mat = transformMatrix([\n    0,\n    0,\n    $bm_div($bm_neg(depth), 2)\n], scale_front, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst tr_back_mat = transformMatrix([\n    0,\n    0,\n    $bm_div(depth, 2)\n], scale_back, zero_center_point_3D, [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], anchor, [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst rot_matrix = transformMatrix([\n    0,\n    0,\n    0\n], 1, [\n    0,\n    0,\n    0\n], [\n    pivot_angleX,\n    pivot_angleY,\n    pivot_angleZ\n], [\n    0,\n    0,\n    0\n], [\n    angleX,\n    angleY,\n    angleZ\n]);\nconst z1_transformed = make_transform(rot_matrix, [\n    0,\n    0,\n    -1\n]);\nconst front_facing_towards_us = isVectorFacingTowardsUs(z1_transformed);\nlet points_front_3D = pnts.map(pnt => make_transform(tr_front_mat, pnt));\nlet points_back_3D = pnts.map(pnt => make_transform(tr_back_mat, pnt));\nlet winding_sides = [];\nlet sorted_sides = [];\nlet sorted_side_colors = [];\nlet num_sides_towards_us = 0;\nfor (var i = 0; i < num_pts; i++) {\n    if (!is_path_closed && i == num_pts - 1) {\n        break;\n    }\n    var F1 = points_front_3D[i], F2 = points_front_3D[(i + 1) % num_pts];\n    var B1 = points_back_3D[i], B2 = points_back_3D[(i + 1) % num_pts];\n    let abs_side_normal = getNormal([\n        F2,\n        F1,\n        B1\n    ], true);\n    let real_side_normal = !is_front_clockwise ? mul(abs_side_normal, -1) : abs_side_normal;\n    const sideIsFacingUs = isFacingTowardsUs([\n        0,\n        0,\n        0\n    ], real_side_normal);\n    if (sideIsFacingUs) {\n        num_sides_towards_us++;\n    }\n    winding_sides.push(sideIsFacingUs);\n    let side_sorted = [\n        F2,\n        F1,\n        B1,\n        B2\n    ];\n    side_sorted.sort((a, b) => b[2] - a[2]);\n    sorted_sides.push([\n        side_sorted,\n        i,\n        $bm_mod($bm_sum(i, 1), num_pts),\n        abs_side_normal\n    ]);\n}\ncompare_sides = function (side1, side2) {\n    const s1_vertices_z = side1[0].map(v => v[2]), s2_vertices_z = side2[0].map(v => v[2]);\n    for (var i = 0, il = side1[0].length; i < il; i++) {\n        if (s1_vertices_z[i] != s2_vertices_z[i]) {\n            return $bm_sub(s2_vertices_z[i], s1_vertices_z[i]);\n        }\n    }\n};\nsorted_sides.sort((a, b) => compare_sides(a, b));\nsorted_sides.sort(function (a, b) {\n    const fa = winding_sides[a[1]], fb = winding_sides[b[1]];\n    if (fa && !fb) {\n        return -1;\n    } else if (!fa && fb) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nsorted_sides_indices = sorted_sides.map(p => [\n    p[1],\n    p[2]\n]);\nif (true) {\n    const lambert_max = extrudalizer('Sides fill shadow opacity').value;\n    const rgba = extrudalizer('Sides color').value;\n    adjustColorBrightness = function (rgba, brightness) {\n        const r = Math.max(0, Math.min(1, $bm_mul(rgba[0], brightness)));\n        const g = Math.max(0, Math.min(1, $bm_mul(rgba[1], brightness)));\n        const b = Math.max(0, Math.min(1, $bm_mul(rgba[2], brightness)));\n        return [\n            Math.round(r * 100) / 100,\n            Math.round(g * 100) / 100,\n            Math.round(b * 100) / 100,\n            rgba[3]\n        ];\n    };\n    lambertShader = function (normal, max_value, multiplier) {\n        return $bm_div($bm_mul($bm_mul(multiplier, $bm_sub(100, max_value)), Math.abs(dot_(normal, [\n            0,\n            0,\n            1\n        ]))), 100);\n    };\n    sorted_side_colors = sorted_sides.map(p => adjustColorBrightness(rgba, lambertShader(p[3], lambert_max, 2)));\n}\nconst front_normal = div(z1_transformed, len_vec(z1_transformed));\nlet bb_front_2D = [], bb_back_2D = [], bb_front_transforms_te = [], bb_back_transforms_te = [], bb_front_transforms_tl = [], bb_back_transforms_tl = [];\nif (use_bb_back || use_bb_front) {\n    const bb = getBoundingBox(pnts);\n    let hasParent = shape_layer.hasParent;\n    let parent_transform_matrix = null;\n    if (hasParent) {\n        let p_pos = shape_layer.parent.transform.position;\n        let p_anchor = shape_layer.parent.transform.anchorPoint;\n        let p_rot = shape_layer.parent.transform.rotation;\n        let p_sca = shape_layer.parent.transform.scale;\n        parent_transform_matrix = get_transform_shape_matrix(p_anchor, p_pos, p_sca, p_rot, 0, 0);\n    }\n    if (use_bb_front) {\n        const bb_front_data = get_transforms_from_bb(bb, tr_front_mat, layer_transform_matrix, parent_transform_matrix, true, front_facing_towards_us, 3);\n        bb_front_2D = bb_front_data['boundingBoxTransformed'];\n        bb_front_transforms_te = bb_front_data['transformEffectControls'];\n        bb_front_transforms_tl = bb_front_data['transformLayerControls'];\n    }\n    if (use_bb_back) {\n        const bb_back_data = get_transforms_from_bb(bb, tr_back_mat, layer_transform_matrix, parent_transform_matrix, false, front_facing_towards_us, 3);\n        bb_back_2D = bb_back_data['boundingBoxTransformed'];\n        bb_back_transforms_te = bb_back_data['transformEffectControls'];\n        bb_back_transforms_tl = bb_back_data['transformLayerControls'];\n    }\n}\nlet grad_property = null;\ntry {\n    grad_property = shape_contents('ADBE Vector Graphic - G-Fill');\n} catch (e) {\n}\nlet grad_start_front_new = [\n    0,\n    0\n];\nlet grad_end_front_new = [\n    0,\n    0\n];\nlet grad_start_back_new = [\n    0,\n    0\n];\nlet grad_end_back_new = [\n    0,\n    0\n];\nif (grad_property != null) {\n    let grad_start = grad_property.startPoint.value;\n    let grad_end = grad_property.endPoint.value;\n    grad_start = transform2D_apply(shape_transform_matrix, grad_start);\n    grad_end = transform2D_apply(shape_transform_matrix, grad_end);\n    const grad_start_front = make_transform(tr_front_mat, grad_start);\n    const grad_end_front = make_transform(tr_front_mat, grad_end);\n    const grad_start_back = make_transform(tr_back_mat, grad_start);\n    const grad_end_back = make_transform(tr_back_mat, grad_end);\n    grad_start_front_new = grad_start_front;\n    grad_end_front_new = grad_end_front;\n    grad_start_back_new = grad_start_back;\n    grad_end_back_new = grad_end_back;\n    const grad_front_rot = $bm_div($bm_mul(extrudalizer('Front gradient direction').value, Math.PI), 180);\n    const grad_back_rot = $bm_div($bm_mul(extrudalizer('Back gradient direction').value, Math.PI), 180);\n    if (!arraysEqual([\n            grad_front_rot,\n            grad_back_rot\n        ], [\n            0,\n            0\n        ])) {\n        const grad_origin_front = div(add(grad_end_front, grad_start_front), 2);\n        const grad_origin_back = div(add(grad_end_back, grad_start_back), 2);\n        const grad_p_st_front = sub(grad_start_front, grad_origin_front);\n        const grad_p_end_front = sub(grad_end_front, grad_origin_front);\n        const grad_p_st_back = sub(grad_start_back, grad_origin_back);\n        const grad_p_end_back = sub(grad_end_back, grad_origin_back);\n        if (grad_front_rot != 0) {\n            const cos_st = Math.cos(grad_front_rot), sin_st = Math.sin(grad_front_rot);\n            grad_start_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_st_front[0]), $bm_mul(sin_st, grad_p_st_front[1])), grad_origin_front[0]);\n            grad_start_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_st_front[0]), $bm_mul(cos_st, grad_p_st_front[1])), grad_origin_front[1]);\n            grad_end_front_new[0] = $bm_sum($bm_sub($bm_mul(cos_st, grad_p_end_front[0]), $bm_mul(sin_st, grad_p_end_front[1])), grad_origin_front[0]);\n            grad_end_front_new[1] = $bm_sum($bm_sum($bm_mul(sin_st, grad_p_end_front[0]), $bm_mul(cos_st, grad_p_end_front[1])), grad_origin_front[1]);\n        }\n        if (grad_back_rot != 0) {\n            const cos_st_b = Math.cos(grad_back_rot), sin_st_b = Math.sin(grad_back_rot);\n            grad_start_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_st_back[0]), $bm_mul(sin_st_b, grad_p_st_back[1])), grad_origin_back[0]);\n            grad_start_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_st_back[0]), $bm_mul(cos_st_b, grad_p_st_back[1])), grad_origin_back[1]);\n            grad_end_back_new[0] = $bm_sum($bm_sub($bm_mul(cos_st_b, grad_p_end_back[0]), $bm_mul(sin_st_b, grad_p_end_back[1])), grad_origin_back[0]);\n            grad_end_back_new[1] = $bm_sum($bm_sum($bm_mul(sin_st_b, grad_p_end_back[0]), $bm_mul(cos_st_b, grad_p_end_back[1])), grad_origin_back[1]);\n        }\n    }\n}\nconst extr_data = [\n    tr_front_mat,\n    tr_back_mat,\n    shape_transform_matrix,\n    subdivs,\n    is_path_closed,\n    points_front_3D,\n    points_back_3D,\n    sorted_sides_indices,\n    front_facing_towards_us,\n    is_front_clockwise,\n    num_sides_towards_us,\n    sorted_side_colors,\n    zero_center_point,\n    front_normal,\n    bb_front_2D,\n    bb_back_2D,\n    bb_front_transforms_te,\n    bb_back_transforms_te,\n    bb_front_transforms_tl,\n    bb_back_transforms_tl,\n    grad_start_front_new,\n    grad_end_front_new,\n    grad_start_back_new,\n    grad_end_back_new\n];\nvar txt = '';\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'] = extr_data;\n} catch (err) {\n    stringify = function (data, separator) {\n        return data.map(item => Array.isArray(item) ? item.join(',') : item.toString()).join(separator);\n    };\n    txt = stringify(extr_data, ';');\n}\n$bm_rt = txt;"},"p":{},"m":{"g":1,"a":{"a":0,"k":[0,0],"ix":2}},"a":[]},"ip":0,"op":72,"st":0,"ct":1,"bm":0}]},{"id":"comp_1","nm":"MAP || Comp 1 || circle_1 || BACK","fr":24,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"MAP || Comp 1 || circle_1 || BACK 2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar dot_, len_vec, angle_between, isStraightLine_w_delta, getPoint, getBoundingBox, multiplyMatrixVector3x3, multiplyMatrices3x3, multiplyArrayOfMatrices3x3, reverseMatrix, transform2D_apply;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    return boundingBox;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nreverseMatrix = function (pivot) {\n    let invertXMatrix = [\n        -1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n    ];\n    var mat_array = [\n        [\n            1,\n            0,\n            -pivot[0],\n            0,\n            1,\n            -pivot[1],\n            0,\n            0,\n            1\n        ],\n        invertXMatrix,\n        [\n            1,\n            0,\n            pivot[0],\n            0,\n            1,\n            pivot[1],\n            0,\n            0,\n            1\n        ]\n    ];\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nconst ex_layer = comp('Head Tail').layer('circle_1');\nlet extr_data_arr;\nlet shape_transform_matrix;\nlet subdivs;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    shape_transform_matrix = extr_data_arr[2];\n    subdivs = extr_data_arr[3];\n} catch (err) {\n    const extr_data = comp('Head Tail').layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    shape_transform_matrix = extr_data_arr[2].split(',').map(s => parseFloat(s));\n    subdivs = parseInt(extr_data_arr[3]);\n}\nconst targetPath = ex_layer(2)(1)(2)(1)(2);\nlet pnts = targetPath.points();\nif (subdivs > 1) {\n    const inTangents = targetPath.inTangents();\n    const outTangents = targetPath.outTangents();\n    var pointsF = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        pointsF.push(pnts[i]);\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    pnts = pointsF;\n}\n;\nlet bb = getBoundingBox(pnts);\nif (false) {\n    pnts = pnts.map(p => transform2D_apply(reverseMatrix(bb.center), p));\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\n$bm_rt = createPath(pnts, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0.086274509804,0.066666666667,0.01568627451,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":true},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[-100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":374,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"MAP || Comp 1 || circle_1 || BACK","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar dot_, len_vec, angle_between, isStraightLine_w_delta, getPoint, getBoundingBox, multiplyMatrixVector3x3, multiplyMatrices3x3, multiplyArrayOfMatrices3x3, reverseMatrix, transform2D_apply;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    return boundingBox;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nreverseMatrix = function (pivot) {\n    let invertXMatrix = [\n        -1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n    ];\n    var mat_array = [\n        [\n            1,\n            0,\n            -pivot[0],\n            0,\n            1,\n            -pivot[1],\n            0,\n            0,\n            1\n        ],\n        invertXMatrix,\n        [\n            1,\n            0,\n            pivot[0],\n            0,\n            1,\n            pivot[1],\n            0,\n            0,\n            1\n        ]\n    ];\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nconst ex_layer = comp('Head Tail').layer('circle_1');\nlet extr_data_arr;\nlet shape_transform_matrix;\nlet subdivs;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    shape_transform_matrix = extr_data_arr[2];\n    subdivs = extr_data_arr[3];\n} catch (err) {\n    const extr_data = comp('Head Tail').layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    shape_transform_matrix = extr_data_arr[2].split(',').map(s => parseFloat(s));\n    subdivs = parseInt(extr_data_arr[3]);\n}\nconst targetPath = ex_layer(2)(1)(2)(1)(2);\nlet pnts = targetPath.points();\nif (subdivs > 1) {\n    const inTangents = targetPath.inTangents();\n    const outTangents = targetPath.outTangents();\n    var pointsF = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        pointsF.push(pnts[i]);\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    pnts = pointsF;\n}\n;\nlet bb = getBoundingBox(pnts);\nif (false) {\n    pnts = pnts.map(p => transform2D_apply(reverseMatrix(bb.center), p));\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\n$bm_rt = createPath(pnts, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[1,1,1,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[-100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":374,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"Tail","tt":1,"tp":2,"refId":"comp_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":180,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[250,250,0],"ix":1,"l":2},"s":{"a":0,"k":[69,69,100],"ix":6,"l":2}},"ao":0,"w":500,"h":500,"ip":0,"op":374,"st":0,"ct":1,"bm":0}]},{"id":"comp_2","nm":"Tail","fr":24,"layers":[{"ddd":0,"ind":1,"ty":2,"nm":"Layer 3","refId":"image_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[250,250,0],"ix":2,"l":2},"a":{"a":0,"k":[223.884,223.884,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":374,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"Layer 1","refId":"image_1","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[0,500,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":374,"st":0,"bm":0}]},{"id":"comp_3","nm":"MAP || Comp 1 || circle_1 || FRONT","fr":24,"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"MAP || Comp 1 || circle_1 || FRONT","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar dot_, len_vec, angle_between, isStraightLine_w_delta, getPoint, getBoundingBox, multiplyMatrixVector3x3, multiplyMatrices3x3, multiplyArrayOfMatrices3x3, reverseMatrix, transform2D_apply;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    return boundingBox;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nreverseMatrix = function (pivot) {\n    let invertXMatrix = [\n        -1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n    ];\n    var mat_array = [\n        [\n            1,\n            0,\n            -pivot[0],\n            0,\n            1,\n            -pivot[1],\n            0,\n            0,\n            1\n        ],\n        invertXMatrix,\n        [\n            1,\n            0,\n            pivot[0],\n            0,\n            1,\n            pivot[1],\n            0,\n            0,\n            1\n        ]\n    ];\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nconst ex_layer = comp('Head Tail').layer('circle_1');\nlet extr_data_arr;\nlet shape_transform_matrix;\nlet subdivs;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    shape_transform_matrix = extr_data_arr[2];\n    subdivs = extr_data_arr[3];\n} catch (err) {\n    const extr_data = comp('Head Tail').layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    shape_transform_matrix = extr_data_arr[2].split(',').map(s => parseFloat(s));\n    subdivs = parseInt(extr_data_arr[3]);\n}\nconst targetPath = ex_layer(2)(1)(2)(1)(2);\nlet pnts = targetPath.points();\nif (subdivs > 1) {\n    const inTangents = targetPath.inTangents();\n    const outTangents = targetPath.outTangents();\n    var pointsF = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        pointsF.push(pnts[i]);\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    pnts = pointsF;\n}\n;\nlet bb = getBoundingBox(pnts);\nif (false) {\n    pnts = pnts.map(p => transform2D_apply(reverseMatrix(bb.center), p));\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\n$bm_rt = createPath(pnts, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0,0,0,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":0,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":374,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":2,"ty":4,"nm":"MAP || Comp 1 || circle_1 || FRONT 2","td":1,"sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[0,0,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"shapes":[{"ty":"gr","it":[{"ind":0,"ty":"sh","ix":1,"ks":{"a":0,"k":{"i":[],"o":[],"v":[],"c":false},"ix":2,"x":"var $bm_rt;\nvar dot_, len_vec, angle_between, isStraightLine_w_delta, getPoint, getBoundingBox, multiplyMatrixVector3x3, multiplyMatrices3x3, multiplyArrayOfMatrices3x3, reverseMatrix, transform2D_apply;\n'use native operators';\ndot_ = function (a, b) {\n    if (a.length == 2) {\n        return $bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1]));\n    } else {\n        return $bm_sum($bm_sum($bm_mul(a[0], b[0]), $bm_mul(a[1], b[1])), $bm_mul(a[2], b[2]));\n    }\n};\nlen_vec = function (a) {\n    return Math.sqrt(dot_(a, a));\n};\nangle_between = function (a, b) {\n    const dot_prod = dot_(a, b);\n    const mag_a = len_vec(a);\n    const mag_b = len_vec(b);\n    const cos_ = $bm_div(dot_prod, $bm_mul(mag_a, mag_b));\n    return cos_;\n};\nisStraightLine_w_delta = function (cp1, cp2, delta) {\n    return angle_between(cp1, cp2) <= -delta;\n};\ngetPoint = function (p1, cp1, cp2, p2, t) {\n    const x = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[0]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[0])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[0])), $bm_mul(Math.pow(t, 3), p2[0]));\n    const y = $bm_sum($bm_sum($bm_sum($bm_mul(Math.pow($bm_sub(1, t), 3), p1[1]), $bm_mul($bm_mul($bm_mul(3, Math.pow($bm_sub(1, t), 2)), t), cp1[1])), $bm_mul($bm_mul($bm_mul(3, $bm_sub(1, t)), Math.pow(t, 2)), cp2[1])), $bm_mul(Math.pow(t, 3), p2[1]));\n    return [\n        x,\n        y\n    ];\n};\ngetBoundingBox = function (points) {\n    const boundingBox = {\n        left: Number.POSITIVE_INFINITY,\n        top: Number.POSITIVE_INFINITY,\n        right: Number.NEGATIVE_INFINITY,\n        bottom: Number.NEGATIVE_INFINITY,\n        width: undefined,\n        height: undefined,\n        center: undefined\n    };\n    points.forEach(point => {\n        boundingBox.left = Math.min(boundingBox.left, point[0]);\n        boundingBox.top = Math.min(boundingBox.top, point[1]);\n        boundingBox.right = Math.max(boundingBox.right, point[0]);\n        boundingBox.bottom = Math.max(boundingBox.bottom, point[1]);\n    });\n    boundingBox.width = sub(boundingBox.right, boundingBox.left);\n    boundingBox.height = sub(boundingBox.bottom, boundingBox.top);\n    boundingBox.center = [\n        add(boundingBox.left, $bm_div(boundingBox.width, 2)),\n        add(boundingBox.top, $bm_div(boundingBox.height, 2))\n    ];\n    return boundingBox;\n};\nmultiplyMatrixVector3x3 = function (matrix, vector) {\n    var result = [\n        0,\n        0,\n        0,\n        0\n    ];\n    for (var i = 0; i < 3; i++) {\n        result[i] = 0;\n        for (var j = 0; j < 3; j++) {\n            result[i] = $bm_sum(result[i], $bm_mul(matrix[$bm_sum($bm_mul(i, 3), j)], vector[j]));\n        }\n    }\n    return result.slice(0, 2);\n};\nmultiplyMatrices3x3 = function (B, A) {\n    let C = new Array(9).fill(0);\n    for (let i = 0; i < 3; i++) {\n        for (let j = 0; j < 3; j++) {\n            for (let k = 0; k < 3; k++) {\n                C[$bm_sum($bm_mul(i, 3), j)] = $bm_sum(C[$bm_sum($bm_mul(i, 3), j)], $bm_mul(A[$bm_sum($bm_mul(i, 3), k)], B[$bm_sum($bm_mul(k, 3), j)]));\n            }\n        }\n    }\n    return C;\n};\nmultiplyArrayOfMatrices3x3 = function (matrices) {\n    if (matrices.length > 0) {\n        var result = matrices[0];\n        for (var i = 1, il = matrices.length; i < il; i++) {\n            result = multiplyMatrices3x3(result, matrices[i]);\n        }\n        return result;\n    } else {\n        return false;\n    }\n};\nreverseMatrix = function (pivot) {\n    let invertXMatrix = [\n        -1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n    ];\n    var mat_array = [\n        [\n            1,\n            0,\n            -pivot[0],\n            0,\n            1,\n            -pivot[1],\n            0,\n            0,\n            1\n        ],\n        invertXMatrix,\n        [\n            1,\n            0,\n            pivot[0],\n            0,\n            1,\n            pivot[1],\n            0,\n            0,\n            1\n        ]\n    ];\n    return multiplyArrayOfMatrices3x3(mat_array);\n};\ntransform2D_apply = function (mt, p) {\n    if (mt == false) {\n        return p;\n    }\n    if (p.length == 2) {\n        p = [\n            ...p,\n            1\n        ];\n    }\n    return multiplyMatrixVector3x3(mt, p).slice(0, 2);\n};\nconst ex_layer = comp('Head Tail').layer('circle_1');\nlet extr_data_arr;\nlet shape_transform_matrix;\nlet subdivs;\ntry {\n    _lottieGlobal.ml_extrudalizer = _lottieGlobal.ml_extrudalizer || {};\n    extr_data_arr = _lottieGlobal.ml_extrudalizer['EXTRUDALIZER DATA || circle_1'];\n    shape_transform_matrix = extr_data_arr[2];\n    subdivs = extr_data_arr[3];\n} catch (err) {\n    const extr_data = comp('Head Tail').layer('EXTRUDALIZER DATA || circle_1').text.sourceText;\n    extr_data_arr = extr_data.split(';');\n    shape_transform_matrix = extr_data_arr[2].split(',').map(s => parseFloat(s));\n    subdivs = parseInt(extr_data_arr[3]);\n}\nconst targetPath = ex_layer(2)(1)(2)(1)(2);\nlet pnts = targetPath.points();\nif (subdivs > 1) {\n    const inTangents = targetPath.inTangents();\n    const outTangents = targetPath.outTangents();\n    var pointsF = [];\n    var num_pnts = pnts.length;\n    for (var i = 0; i < num_pnts; i++) {\n        var p1 = pnts[i], p2 = pnts[(i + 1) % num_pnts];\n        var out1 = outTangents[i], in2 = inTangents[(i + 1) % num_pnts];\n        var cp1 = add(p1, out1), cp2 = add(p2, in2);\n        var len_out1 = len_vec(out1), len_in2 = len_vec(in2);\n        var len_p1p2 = len_vec(sub(p2, p1));\n        pointsF.push(pnts[i]);\n        if (len_out1 !== 0 || len_in2 !== 0) {\n            var a = len_out1 === 0 ? sub(p2, p1) : out1;\n            var b = len_in2 === 0 ? sub(p1, p2) : in2;\n            if (!isStraightLine_w_delta(a, b, 0.999) && (len_out1 > len_p1p2 * 0.02 || len_in2 > len_p1p2 * 0.02)) {\n                for (var j = 1; j < subdivs; j++) {\n                    var t = $bm_div(j, subdivs);\n                    pointsF.push(getPoint(p1, cp1, cp2, p2, t));\n                }\n                ;\n            }\n            ;\n        }\n        ;\n    }\n    ;\n    pnts = pointsF;\n}\n;\nlet bb = getBoundingBox(pnts);\nif (false) {\n    pnts = pnts.map(p => transform2D_apply(reverseMatrix(bb.center), p));\n}\npnts = pnts.map(p => transform2D_apply(shape_transform_matrix, p));\n$bm_rt = createPath(pnts, [], [], true);"},"nm":"ORIGIN PATH","mn":"ADBE Vector Shape - Group","hd":false},{"ty":"st","c":{"a":0,"k":[0,0,0,1],"ix":3},"o":{"a":0,"k":100,"ix":4},"w":{"a":0,"k":3,"ix":5},"lc":1,"lj":1,"ml":4,"bm":0,"nm":"Stroke 1","mn":"ADBE Vector Graphic - Stroke","hd":false},{"ty":"fl","c":{"a":0,"k":[1,1,1,1],"ix":4},"o":{"a":0,"k":100,"ix":5},"r":1,"bm":0,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill","hd":false},{"ty":"tr","p":{"a":0,"k":[0,0],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"ORIGIN SHAPE","np":3,"cix":2,"bm":0,"ix":1,"mn":"ADBE Vector Group","hd":false}],"ip":0,"op":374,"st":0,"ct":1,"bm":0},{"ddd":0,"ind":3,"ty":0,"nm":"Head","tt":1,"tp":2,"refId":"comp_4","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[150,150,0],"ix":2,"l":2},"a":{"a":0,"k":[250,250,0],"ix":1,"l":2},"s":{"a":0,"k":[69,69,100],"ix":6,"l":2}},"ao":0,"w":500,"h":500,"ip":0,"op":374,"st":0,"ct":1,"bm":0}]},{"id":"comp_4","nm":"Head","fr":24,"layers":[{"ddd":0,"ind":1,"ty":2,"nm":"Layer 4","refId":"image_2","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[250,249.346,0],"ix":2,"l":2},"a":{"a":0,"k":[223.884,223.921,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":374,"st":0,"bm":0},{"ddd":0,"ind":2,"ty":2,"nm":"Layer 2","refId":"image_3","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[250,250,0],"ix":2,"l":2},"a":{"a":0,"k":[224.651,224.651,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"ip":0,"op":374,"st":0,"bm":0}]}],"fonts":{"list":[{"origin":0,"fPath":"","fClass":"","fFamily":"Montserrat","fWeight":"","fStyle":"Black","fName":"Montserrat-Black","ascent":74.1989135742188}]},"layers":[{"ddd":0,"ind":1,"ty":0,"nm":"Head Tail","refId":"comp_0","sr":1,"ks":{"o":{"a":0,"k":100,"ix":11},"r":{"a":0,"k":0,"ix":10},"p":{"a":0,"k":[151,152,0],"ix":2,"l":2},"a":{"a":0,"k":[250,250,0],"ix":1,"l":2},"s":{"a":0,"k":[100,100,100],"ix":6,"l":2}},"ao":0,"w":500,"h":500,"ip":0,"op":72,"st":0,"bm":0}],"markers":[],"props":{}}